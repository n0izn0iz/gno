package payrolls

import (
	"net/url"
	"std"
	"strconv"
	"strings"
	"time"

	"gno.land/p/demo/avl"
	"gno.land/p/demo/seqid"
	"gno.land/p/demo/ufmt"
	"gno.land/p/demo/unicoin"
	"gno.land/p/demo/users"
	rusers "gno.land/r/demo/users"
)

const (
	listMaxSize   = 50
	defaultFqname = "gno.land/r/demo/foo20"
	defaultDenom  = "/r20/" + defaultFqname
)

func Render(renderPath string) string {
	w := strings.Builder{}

	switch {
	case strings.HasPrefix(renderPath, "/u/"):
		w.WriteString("# Payrolls beneficiary\n")

		path := strings.TrimPrefix(renderPath, "/u/")
		aon := users.AddressOrName(path)
		user := rusers.GetUserByAddressOrName(aon)
		addr := std.Address(aon)
		if user != nil {
			addr = user.Address
			w.WriteString(ufmt.Sprintf("- üë§ User: @%s\n", user.Name))
		} else if !addr.IsValid() {
			w.WriteString(ufmt.Sprintf("‚ùì User %q not found\n", addr.String()))
			break
		}

		w.WriteString(ufmt.Sprintf("- üÜî Address: %s\n", addr.String()))

		sb := strings.Builder{}
		tree, ok := payrollsByBeneficiary[addr]
		if !ok {
			tree = avl.NewTree()
		}
		estimatedDay := unicoin.Unicoins{}
		estimatedAvailable := unicoin.Unicoins{}
		estimatedClaimable := unicoin.Unicoins{}
		shouldEstimate := tree.Size() <= listMaxSize
		if shouldEstimate {
			sb.WriteString("## All payrolls\n")
		} else {
			sb.WriteString("## Latest payrolls\n")
		}
		tree.ReverseIterateByOffset(0, listMaxSize, func(key string, value interface{}) bool {
			p := value.(*payroll)
			sb.WriteString(renderPayroll(p, "beneficiary"))

			if shouldEstimate {
				available := p.available()
				estimatedAvailable = estimatedAvailable.Add(available)

				claimable := available.ClampMax(getVaultCoins(p.vaultID))
				estimatedClaimable = estimatedClaimable.Add(claimable)

				estimatedDay = estimatedDay.Add(p.estimateDay())
			}

			return false
		})

		actions := []string{}

		if !shouldEstimate || !estimatedClaimable.Empty() {
			actions = append(actions, renderButton("Claim all", "ClaimAll", map[string]string{
				"destination": addr.String(),
			}))
		}

		actions = append(actions, renderButton("New payroll", "CreateMonthlyContinuous", map[string]string{
			"label":          "Salary Monthly",
			"beneficiary":    addr.String(),
			"amountPerMonth": "10000" + defaultDenom,
		}))

		w.WriteString(renderActions("", actions))

		if shouldEstimate {
			estimatedAvailable.Add(estimatedDay).ForEach(func(kind unicoin.Kind, coin std.Coin) {
				w.WriteString(ufmt.Sprintf("- %s:\n", renderCoinDenom(kind, coin.Denom)))
				w.WriteString(renderEstimatedMonthly("  ", kind, estimatedDay[kind].AmountOf(coin.Denom), coin.Denom))
				w.WriteString(renderClaimable("  ", kind, estimatedClaimable[kind].AmountOf(coin.Denom), estimatedAvailable[kind].AmountOf(coin.Denom), coin.Denom, true))
			})
		}

		w.WriteString(sb.String())

	case strings.HasPrefix(renderPath, "/v/"):
		w.WriteString("# Payrolls vault\n")

		input := strings.TrimPrefix(renderPath, "/v/")
		inputBase, namespace := splitVaultInput(input)
		base, vaultUser, ok := resolveVaultBase(inputBase)
		if !ok {
			w.WriteString(ufmt.Sprintf("‚ùì Vault %q not found", input))
			break
		}

		vaultID := vaultIDUnsafe(base, namespace)

		name := vaultID
		if vaultUser != nil {
			name = vaultIDUnsafe("@"+vaultUser.Name, namespace)
		}
		w.WriteString(ufmt.Sprintf("- üé© Name: %s\n", name))

		w.WriteString(ufmt.Sprintf("- üÜî ID: %s\n", vaultID))

		payrollsBuffer := strings.Builder{}
		estimatedDay := unicoin.Unicoins{}
		estimatedDebt := unicoin.Unicoins{}
		tree, ok := payrollsByVault[vaultID]
		if !ok {
			tree = avl.NewTree()
		}
		shouldEstimate := tree.Size() <= listMaxSize
		if shouldEstimate {
			payrollsBuffer.WriteString("## All payrolls\n")
		} else {
			payrollsBuffer.WriteString("## Latest payrolls\n")
		}
		tree.ReverseIterateByOffset(0, listMaxSize, func(key string, value interface{}) bool {
			p := value.(*payroll)
			if shouldEstimate {
				estimatedDebt = estimatedDebt.Add(p.available())
				estimatedDay = estimatedDay.Add(p.estimateDay())
			}
			payrollsBuffer.WriteString(renderPayroll(p, "vault"))
			return false
		})

		funds := getVaultCoins(vaultID)
		balance := funds.Sub(estimatedDebt)

		actions := []string{}
		actions = append(actions, renderButton("Deposit native", "FundFromArgs", map[string]string{
			"base":      base,
			"namespace": namespace,
		}))
		actions = append(actions, renderButton("Deposit GRC20", "FundFromArgs", map[string]string{
			"base":      base,
			"namespace": namespace,
			"uniarg":    "any" + defaultDenom,
		}))
		if !shouldEstimate || balance.HasPositive() {
			actions = append(actions, renderButton("Withdraw funds", "WithdrawFundsFromArgs", map[string]string{
				"namespace": namespace,
			}))
		}
		actions = append(actions, renderButton("New payroll", "CreateMonthlyContinuous", map[string]string{
			"namespace":      namespace,
			"label":          "Salary Monthly",
			"amountPerMonth": "10000" + defaultDenom,
		}))
		w.WriteString(renderActions("", actions))

		if shouldEstimate {
			balance.Add(estimatedDay).ForEach(func(kind unicoin.Kind, coin std.Coin) {
				w.WriteString(ufmt.Sprintf("- %s:\n", renderCoinDenom(kind, coin.Denom)))

				color := "üü¢"
				coinBalance := balance[kind].AmountOf(coin.Denom)
				if coinBalance < 0 {
					color = "üî¥"
				}
				w.WriteString(ufmt.Sprintf("  - üè¶ Funds: %s %s\n", color, renderCoin(kind, std.NewCoin(coin.Denom, coinBalance))))

				w.WriteString(renderEstimatedMonthly("  ", kind, estimatedDay[kind].AmountOf(coin.Denom), coin.Denom))

				if coinBalance > 0 && estimatedDay[kind].AmountOf(coin.Denom) > 0 {
					color := "üî¥"
					runWayMonths := coinBalance / (estimatedDay[kind].AmountOf(coin.Denom) * 30)
					if runWayMonths >= 12 {
						color = "üü¢"
					} else if runWayMonths >= 6 {
						color = "üü†"
					}
					w.WriteString(ufmt.Sprintf("  - üõ¨ Estimated runway: %s %d months\n", color, runWayMonths))
				}
			})
		} else {
			funds.ForEach(func(kind unicoin.Kind, coin std.Coin) {
				w.WriteString(ufmt.Sprintf("- üè¶ Funds: %d %s (does not account for unclaimed amounts)\n", renderCoin(kind, coin)))
			})
		}

		w.WriteString(payrollsBuffer.String())

	case strings.HasPrefix(renderPath, "/d/"):
		idStr := strings.TrimPrefix(renderPath, "/d/")

		w.WriteString(ufmt.Sprintf("# Payroll #%s\n", idStr))

		p, ok := payrolls.Get(idStr)
		if !ok {
			return ufmt.Sprintf("‚ùì Payroll %q not found", idStr)
		}

		w.WriteString(renderPayroll(p.(*payroll), "details"))

	case renderPath == "/vdbg":
		w.WriteString("# Payrolls vaults debug\n")

		vaults.Iterate("", "", func(key string, value interface{}) bool {
			w.WriteString(ufmt.Sprintf("## %s\n", key))
			value.(unicoin.Unicoins).ForEach(func(kind unicoin.Kind, coin std.Coin) {
				w.WriteString(ufmt.Sprintf("  - %d %q\n", coin.Amount, "/"+kind.String()+"/"+coin.Denom))
			})
			return false
		})

	case renderPath == "":
		w.WriteString("# Payrolls\n")

		actions := []string{}
		actions = append(actions, renderButton("New payroll", "CreateMonthlyContinuous", map[string]string{
			"label":          "Salary Monthly",
			"amountPerMonth": "10000" + defaultDenom,
		}))
		w.WriteString(renderActions("", actions))

		if payrolls.Size() <= listMaxSize {
			w.WriteString("## All payrolls\n")
		} else {
			w.WriteString("## Latest payrolls\n")
		}
		payrolls.ReverseIterateByOffset(0, listMaxSize, func(key string, value interface{}) bool {
			w.WriteString(renderPayroll(value.(*payroll), "home"))
			return false
		})

		/*
			w.WriteString("## v2 ideas\n")
			w.WriteString("- Better test coverage\n")
			w.WriteString("- Gnoweb pagination\n")
			w.WriteString("- Show payroll running duration\n")
			w.WriteString("- Archive\n")
			w.WriteString("- Details: Events history\n")
			w.WriteString("- PoV Tags\n")
			w.WriteString("- Edit label / PoV labels\n")
			w.WriteString("- Stop litigation\n")
		*/

	default:
		w.WriteString("# Payrolls\n")
		w.WriteString("‚ùì 404 Not found")
	}

	return w.String()
}

func renderPayroll(p *payroll, pov string) string {
	sb := strings.Builder{}

	if pov != "details" {
		sb.WriteString(ufmt.Sprintf("### %s\n", p.id.String()))
	}

	sb.WriteString(ufmt.Sprintf("  - ‚úçÔ∏è Label: %s\n", p.label))

	if p.paused {
		sb.WriteString(ufmt.Sprintf("  - ‚è∏Ô∏è Paused since: %s\n", p.pausedAt.Format(time.DateTime)))
	}

	if pov != "vault" {
		base, namespace := splitVaultInput(p.vaultID)
		_, usr, _ := resolveVaultBase(base)
		if usr != nil {
			base = "@" + usr.Name
		}
		pvid := vaultIDUnsafe(base, namespace)
		sb.WriteString(ufmt.Sprintf("  - üé© Vault: [%s](%s:/v/%s)\n", pvid, linkPrefix(), pvid))
	}

	if pov != "beneficiary" {
		beneficiaryUser := rusers.GetUserByAddress(p.beneficiary)
		var userStr string
		if beneficiaryUser == nil {
			userStr = p.beneficiary.String()
		} else {
			userStr = "@" + beneficiaryUser.Name
		}
		sb.WriteString(ufmt.Sprintf("  - üë§ Beneficiary: [%s](%s:/u/%s)\n", userStr, linkPrefix(), userStr))
	}

	available := p.available()
	vaultAmount := getVaultCoins(p.vaultID)
	claimable := available.ClampMax(vaultAmount)

	sb.WriteString(ufmt.Sprintf("  - üèÅ Created at: %s\n", p.createdAt.Format(time.DateTime)))

	if p.stopped {
		sb.WriteString(ufmt.Sprintf("  - üõë Stopped since: %s\n", p.stoppedAt.Format(time.DateTime)))
	}

	if pov != "details" {
		sb.WriteString(ufmt.Sprintf("  - üîç [Details](%s:/d/%s)\n", linkPrefix(), p.id.String()))
	}

	actions := []string{}

	if pov != "vault" && claimable.HasPositive() {
		actions = append(actions, renderButton("Claim", "Claim", map[string]string{
			"id":          strconv.FormatUint(uint64(p.id), 10),
			"destination": p.beneficiary.String(),
		}))
	}

	if pov != "vault" && !p.paused && !p.stopped {
		actions = append(actions, renderButton("Pause", "Pause", map[string]string{
			"id": strconv.FormatUint(uint64(p.id), 10),
		}))
	}

	if pov != "vault" && p.paused {
		actions = append(actions, renderButton("Resume", "Resume", map[string]string{
			"id": strconv.FormatUint(uint64(p.id), 10),
		}))
	}

	if !p.stopped {
		actions = append(actions, renderStopButton(p.id))
	}

	sb.WriteString(renderActions("  ", actions))

	estimatedDay := p.estimateDay()
	allCoins := available.Add(estimatedDay)

	beneficiaryBreakupCoins := unicoin.Unicoins{}
	creatorBreakupCoins := unicoin.Unicoins{}
	if pov == "details" {
		allCoins = allCoins.Add(beneficiaryBreakupCoins)
		allCoins = allCoins.Add(creatorBreakupCoins)
		beneficiaryBreakupCoins = p.getBreakupCoins(CallSourceBeneficiary)
		creatorBreakupCoins = p.getBreakupCoins(CallSourceCreator)
	}
	allCoins.ForEach(func(kind unicoin.Kind, coin std.Coin) {
		sb.WriteString(ufmt.Sprintf("  - %s:\n", renderCoinDenom(kind, coin.Denom)))
		sb.WriteString(renderEstimatedMonthly("    ", kind, estimatedDay[kind].AmountOf(coin.Denom), coin.Denom))
		sb.WriteString(renderClaimable("    ", kind, claimable[kind].AmountOf(coin.Denom), available[kind].AmountOf(coin.Denom), coin.Denom, true))
		if pov == "details" {
			if bb := beneficiaryBreakupCoins[kind].AmountOf(coin.Denom); bb > 0 {
				sb.WriteString(ufmt.Sprintf("    - Breakup by beneficiary bonus: %s\n", renderCoin(kind, std.NewCoin(coin.Denom, bb))))
			}
			if cb := creatorBreakupCoins[kind].AmountOf(coin.Denom); cb > 0 {
				sb.WriteString(ufmt.Sprintf("    - Breakup by creator bonus: %s\n", renderCoin(kind, std.NewCoin(coin.Denom, cb))))
			}
		}
	})

	return sb.String()
}

func renderClaimable(prefix string, kind unicoin.Kind, claimable int64, available int64, denom string, plural bool) string {
	if available == 0 {
		return ""
	}
	sb := strings.Builder{}
	sb.WriteString(prefix)
	sb.WriteString("- üíµ Claimable: ")
	if claimable < available {
		pls := ""
		if plural {
			pls = "(s)"
		}
		color := "üü†"
		if claimable == 0 {
			color = "üî¥"
		}
		sb.WriteString(ufmt.Sprintf("%s %s/%s %s (not enough funds in vault%s!)\n",
			color,
			renderCoinAmount(kind, std.NewCoin(denom, claimable)),
			renderCoinAmount(kind, std.NewCoin(denom, available)),
			renderCoinDenom(kind, denom),
			pls,
		))
	} else {
		sb.WriteString(ufmt.Sprintf("üü¢ %s\n", renderCoin(kind, std.NewCoin(denom, available))))
	}
	return sb.String()
}

func renderEstimatedMonthly(prefix string, kind unicoin.Kind, estimatedDay int64, denom string) string {
	if estimatedDay == 0 {
		return ""
	}
	return ufmt.Sprintf("%s- üí∏ Estimated monthly: %s\n", prefix, renderCoin(kind, std.NewCoin(denom, estimatedDay*30)))
}

func renderStopButton(id seqid.ID) string {
	return renderButton("Stop", "Stop", map[string]string{
		"id": strconv.FormatUint(uint64(id), 10),
	})
}

func renderButton(text, funcName string, args map[string]string) string {
	argsBuf := strings.Builder{}
	for key, arg := range args {
		argsBuf.WriteString("&" + url.QueryEscape(key) + "=" + url.QueryEscape(arg))
	}
	return ufmt.Sprintf("[[%s]](%s$help&func=%s%s)", text, linkPrefix(), funcName, argsBuf.String())
}

func renderActions(prefix string, actions []string) string {
	if len(actions) == 0 {
		return ""
	}
	return prefix + "- ‚úã Actions: " + strings.Join(actions, " ") + "\n"
}

func resolveVaultBase(base string) (string, *users.User, bool) {
	if len(base) == 0 {
		return "", nil, false
	}

	if strings.HasPrefix(base, std.GetChainDomain()+"/r/") {
		return base, nil, true
	}

	usr := rusers.GetUserByAddressOrName(users.AddressOrName(base))
	if usr != nil {
		return usr.Address.String(), usr, true
	}

	if std.Address(base).IsValid() {
		return base, nil, true
	}

	return "", nil, false
}

func linkPrefix() string {
	realmPath := std.CurrentRealm().PkgPath()
	slashIdx := strings.Index(realmPath, "/")
	if slashIdx == -1 {
		return realmPath
	}
	return realmPath[slashIdx:]
}

func renderCoin(kind unicoin.Kind, coin std.Coin) string {
	return ufmt.Sprintf("%s %s", renderCoinAmount(kind, coin), renderCoinDenom(kind, coin.Denom))
}

func renderCoinAmount(kind unicoin.Kind, coin std.Coin) string {
	ctx, ok := uccp.Get(kind)
	if !ok {
		return strconv.FormatInt(coin.Amount, 10)
	}
	return ctx.RenderAmount(coin)
}

func renderCoinDenom(kind unicoin.Kind, denom string) string {
	ctx, ok := uccp.Get(kind)
	if !ok {
		return denom
	}
	return ctx.RenderDenom(denom)
}
