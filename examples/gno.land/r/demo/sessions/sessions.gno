// Package sessions implements an authenticator that allows a mother entity to
// whitelist session entities that can then act as the mother entity using auth tokens.
package sessions

import (
	"errors"
	"path"
	"std"
	"time"

	"gno.land/p/demo/auth"
	"gno.land/r/demo/authreg"
)

var (
	sessions map[string]map[string]*time.Time
	source   std.Realm
)

const NoExpiry = int64(0)

func init() {
	sessions = make(map[string]map[string]*time.Time)
	source = std.CurrentRealm()

	authreg.Register(Authenticate)
}

// Login creates a session allowing an entity identified by sessionEntityID to act as the entity authenticated via authok until we're past the expiry time.
// A nil expiry creates a session with no expiration
func Login(authok auth.Token, sessionEntityID string, unixSecondsExpiry int64) {
	motherEntityID := authreg.Authenticate(authok)

	if unixSecondsExpiry < 0 {
		panic(errors.New("negative expiry"))
	}
	expiry := (*time.Time)(nil)
	if unixSecondsExpiry > 0 {
		timeExpiry := time.Unix(unixSecondsExpiry, 0)
		expiry = &timeExpiry
		if !expiry.After(time.Now()) {
			panic(errors.New("expiry is now or in the past"))
		}
	}

	if _, ok := sessions[motherEntityID]; !ok {
		sessions[motherEntityID] = make(map[string]*time.Time)
	}

	sessions[motherEntityID][sessionEntityID] = expiry
}

// LogoutFromSession allows to delete a session when authenticated as the session's entity
func LogoutFromSession(autok auth.Token, motherEntityID string) {
	sessionEntityID := authreg.Authenticate(autok)

	motherEntitySessions, ok := sessions[motherEntityID]
	if !ok {
		panic(errors.New("entity has no sessions"))
	}

	if _, ok := motherEntitySessions[sessionEntityID]; !ok {
		panic(errors.New("the authenticated entity is not a session of this entity"))
	}

	// delete all sessions if it was the last one
	if len(motherEntitySessions) == 1 {
		delete(sessions, motherEntityID)
		return
	}

	delete(motherEntitySessions, sessionEntityID)
}

// Logout allows to delete sessions when authenticated as the mother entity
func Logout(autok auth.Token, sessionEntityID string) {
	motherEntityID := authreg.Authenticate(autok)

	entitySessions, ok := sessions[motherEntityID]
	if !ok {
		panic("entity has no sessions")
	}

	if _, ok := entitySessions[sessionEntityID]; !ok {
		panic("the authenticated entity is not a session of this entity")
	}

	// delete all sessions if it was the last one
	if len(entitySessions) == 1 {
		delete(sessions, motherEntityID)
		return
	}

	delete(entitySessions, sessionEntityID)
}

// LogoutAll allows to delete all sessions for an entity
func LogoutAll(autok auth.Token) {
	entityID := authreg.Authenticate(autok)

	if _, ok := sessions[entityID]; !ok {
		panic(errors.New("entity has no sessions"))
	}

	delete(sessions, entityID)
}

// AuthToken constructs a session token.
func AuthToken(sessionToken auth.Token, motherEntityID string) auth.Token {
	return &token{
		sessionToken:   sessionToken,
		motherEntityID: motherEntityID,
	}
}

// Authenticate validates a token generated by [AuthToken]. It panics if the session does not exists or is expired
func Authenticate(autok auth.Token) string {
	val, ok := autok.(*token)
	if !ok || val == nil {
		panic(auth.ErrInvalidToken)
	}

	motherEntityID := val.motherEntityID
	sessionEntityID := authreg.Authenticate(val.sessionToken)

	if motherEntityID != sessionEntityID {
		expiry, ok := sessions[motherEntityID][sessionEntityID]
		if !ok {
			panic(auth.ErrInvalidToken)
		}
		if expiry != nil && !time.Now().Before(*expiry) {
			panic(auth.ErrInvalidToken)
		}
	}

	return path.Join("/", motherEntityID)
}

// EntityID returns the full entity ID for a mother entity
func EntityID(motherEntityID string) string {
	return auth.NamespacedEntityID(authreg.ProviderSlug(source), motherEntityID)
}

type token struct {
	sessionToken   auth.Token
	motherEntityID string
}

func (t *token) Source() std.Realm {
	return source
}
